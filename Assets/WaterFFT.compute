// https://www.keithlantz.net/2011/10/ocean-simulation-part-one-using-the-discrete-fourier-transform/

#pragma kernel CS_ComputeHeightField

#define PI 3.14159265358979323846264338f
#define G 9.81f
#define G_SQRT 3.13209195267f

int _N;
float _L;

// Phillips parameters
float2 _w; // Wind dir
float _V; // Wind speed
float _A; // I still don't know what this param does
float _dt; // Delta time
float _t; // Time

RWTexture2D<float> _result;

//
//  DEBUG
//

//
//
//
// RANDOM GAUSSIAN VALUE FROM https://www.shadertoy.com/view/MlVSzw
#define  NUM_BUCKETS 32
#define ITER_PER_BUCKET 1024
#define  HIST_SCALE 8.0

#define NUM_BUCKETS_F float(NUM_BUCKETS)
#define ITER_PER_BUCKET_F float(ITER_PER_BUCKET)

//note: uniformly distributed, normalized rand, [0;1[
float nrand( float2 n )
{
    return sin(dot(n.xy, float2(12.9898, 78.233)))* 43758.5453%1.0f;
}
//note: remaps v to [0;1] in interval [a;b]
float remap( float a, float b, float v )
{
    return clamp( (v-a) / (b-a), 0.0, 1.0 );
}
//note: quantizes in l levels
float _trunc( float a, float l )
{
    return floor(a*l)/l;
}

float n8rand( float2 n )
{
    float t = _dt % 1.0f;
    float nrnd0 = nrand( n + 0.07*t );
    float nrnd1 = nrand( n + 0.11*t );	
    float nrnd2 = nrand( n + 0.13*t );
    float nrnd3 = nrand( n + 0.17*t );
    float nrnd4 = nrand( n + 0.19*t );
    float nrnd5 = nrand( n + 0.23*t );
    float nrnd6 = nrand( n + 0.29*t );
    float nrnd7 = nrand( n + 0.31*t );
    
    return (nrnd0+nrnd1+nrnd2+nrnd3 +nrnd4+nrnd5+nrnd6+nrnd7) / 8.0;
}

#define ALPHA 0.14
#define INV_ALPHA 1.0 / ALPHA
#define K_RAND 2.0 / (PI * ALPHA)

float inv_error_function(float x)
{
    float y = log(1.0 - x*x);
    float z = K_RAND + 0.5 * y;
    return sqrt(sqrt(z*z - y * INV_ALPHA) - z) * sign(x);
}

float gaussian_rand( float2 n )
{
    float t = _dt % 1.0f;
    float x = n8rand( n + 0.07*t );
    
    return inv_error_function(x*2.0-1.0)*0.15 + 0.5;
}
//
//
//

float2 conj(float2 v)
{
    return float2(v.x, -v.y);
}

float2 K(int n_prime, int m_prime)
{
    return float2((2*PI*n_prime-PI*_N)/_L, (2*PI*m_prime-PI*_N)/_L);
}

float dispersion(float n_prime, float m_prime)
{
    return G_SQRT * sqrt(length(K(n_prime, m_prime)));
}

float phillips(int n_prime, int m_prime)
{
    const float l = (_V*_V)/G;

    const float2 k = K(n_prime, m_prime);
    const float k_length = length(k);
    const float k_length2 = k_length * k_length;
    const float k_length4 = k_length2* k_length2;

    const float dot_prod = dot(_w, k);
    const float frac_top = exp(-1.0f/(k_length2*l*l));

    return _A*(frac_top/k_length4)*dot_prod*dot_prod;
}

float2 h_tilde0(float n_prime, float m_prime)
{
    const float2 k = K(n_prime, m_prime);

    const float one_over_sqrt2 = 0.70710678118f;

    float e1 = gaussian_rand(k);
    float e2 = gaussian_rand(normalize(k*e1));
    
    return one_over_sqrt2*float2(e1, e2)*sqrt(phillips(n_prime, m_prime));
}

float2 h_tilde(float n_prime, float m_prime, float t)
{
    const float2 ht0 = h_tilde0(n_prime, m_prime);
    const float2 ht0conj = conj(h_tilde0(-n_prime, -m_prime));

    const float omegat = dispersion(n_prime, m_prime) * t;

    const float c = cos(omegat);
    const float s = sin(omegat);

    const float2 c0 = float2(c, s);
    const float2 c1 = float2(c, -s);

    return ht0 * c0 + ht0conj * c1;
}

[numthreads(1,1,1)]
void CS_ComputeHeightField(uint3 id : SV_DispatchThreadID)
{

}