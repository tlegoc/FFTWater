// https://www.keithlantz.net/2011/10/ocean-simulation-part-one-using-the-discrete-fourier-transform/

#pragma kernel CS_ComputeHeightField

#define PI 3.14159265358979323846264338f
#define G 9.81f
#define G_SQRT 3.13209195267f

int _N;
float _L;

// Phillips parameters
float2 _w; // Wind dir
float _V; // Wind speed
float _A; // I still don't know what this param does
float _dt; // Delta time
float _t; // Time
int _Seed;

RWTexture2D<float> _result;

//
//
// https://github.com/GarrettGunnell/Water/blob/main/Assets/Shaders/FFTWater.compute
float hash(uint n) {
    // integer hash copied from Hugo Elias
    n = (n << 13U) ^ n;
    n = n * (n * n * 15731U + 0x789221U) + 0x1376312589U;
    return float(n & uint(0x7fffffffU)) / float(0x7fffffff);
}

float2 UniformToGaussian(float u1, float u2) {
    float R = sqrt(-2.0f * log(u1));
    float theta = 2.0f * PI * u2;

    return float2(R * cos(theta), R * sin(theta));
}
//
//
//

float2 complexMul(float2 a, float2 b)
{
    return float2(a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x);
}

float2 conj(float2 v)
{
    return float2(v.x, -v.y);
}

float2 K(int n_prime, int m_prime)
{
    return float2((2*PI*n_prime-PI*_N)/_L, (2*PI*m_prime-PI*_N)/_L);
}

float dispersion(float n_prime, float m_prime)
{
    return G_SQRT * sqrt(length(K(n_prime, m_prime)));
}

float phillips(int n_prime, int m_prime)
{
    const float l = (_V*_V)/G;

    const float2 k = K(n_prime, m_prime);
    const float k_length = length(k);
    const float k_length2 = k_length * k_length;
    const float k_length4 = k_length2* k_length2;

    const float dot_prod = dot(_w, k);
    const float frac_top = exp(-1.0f/(k_length2*l*l));

    return _A*(frac_top/k_length4)*dot_prod*dot_prod;
}

float2 h_tilde0(float n_prime, float m_prime)
{
    uint seed = n_prime + _N * m_prime + _N + _Seed;
    const float2 k = K(n_prime, m_prime);

    const float one_over_sqrt2 = 0.70710678118f;
    
    float4 uniformRandSamples = float4(hash(seed), hash(seed * 2), hash(seed * 3), hash(seed * 4));
    float2 e = UniformToGaussian(uniformRandSamples.x, uniformRandSamples.y);
    
    return one_over_sqrt2*e*sqrt(phillips(n_prime, m_prime));
}

float2 h_tilde(float n_prime, float m_prime, float t)
{
    const float2 ht0 = h_tilde0(n_prime, m_prime);
    const float2 ht0conj = conj(h_tilde0(-n_prime, -m_prime));

    const float omegat = dispersion(n_prime, m_prime) * t;

    const float c = cos(omegat);
    const float s = sin(omegat);

    const float2 c0 = float2(c, s);
    const float2 c1 = float2(c, -s);

    return ht0 * c0 + ht0conj * c1;
}

[numthreads(1,1,1)]
void CS_ComputeHeightField(uint3 id : SV_DispatchThreadID)
{
    uint seed = id.x + _N * id.y + _N;
    seed += _Seed;
    float2 uniformRandSamples = float2(hash(seed), hash(seed * 2));
    _result[id.xy] = UniformToGaussian(uniformRandSamples.x, uniformRandSamples.y).x;
    
}